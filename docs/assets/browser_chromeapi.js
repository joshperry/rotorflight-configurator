const C=function(){let t,o;const s="SERIAL (adapted from WebSerial):";function d(i,...n){console.log(s+i,...n)}function l(i,...n){console.warn(s+i,...n)}function h(i,...n){console.error(s+i,...n)}function g(i,n,u){chrome.runtime.lastError=i;try{n?.(u)}catch(y){h("error calling chrome callback",y)}finally{chrome.runtime.lastError=null}}function f(i){return{path:`usb_${i.serialNumber}`,productName:i.productName,vendorId:i.manufacturerName,productId:i.productName,device:new Date/1e3}}function m(i,n){n?.(t?[t]:[])}async function b(i,n){try{await o.open(),n?.({handle:i.device,productId:i.productId,vendorId:i.vendorId})}catch(u){g(u,n)}}async function w(i,n){try{await o.close(),n?.()}catch(u){g(u,n)}}async function v(i,n){try{await o.reset(),n?.()}catch(u){g(u,n)}}async function P(i,n,u){try{await o.claimInterface(n),u?.()}catch(y){g(y,u)}}async function B(i,n,u){try{await o.releaseInterface(n),u?.()}catch(y){g(y,u)}}async function A(i,n){try{o.configuration===null&&await o.getConfiguration(1),n?.(o.configuration)}catch(u){g(u,n)}}async function L(i,n,u){try{const y=(({requestType:p,recipient:S,request:D,value:r,index:e})=>({requestType:p,recipient:S,request:D,value:r,index:e}))(n);if(n.direction==="out"){const p=n.data?n.data:new ArrayBuffer(0),S=await o.controlTransferOut(y,p);u?.({data:void 0,resultCode:S.resultCode})}else{const p=await o.controlTransferIn(y,n.length);p.status==="ok"?u?.({data:p.data.buffer,resultCode:p.resultCode}):(l("Error status from control transfer in",p),g(new Error(p.status),u,{resultCode:1}))}}catch(y){h("Controltransfer error",y),g(y,u,{resultCode:1})}}async function E(i){try{const n=await navigator.usb.requestDevice(i);return d("User selected USB device from permissions:",n),d(`WebUSB Version: ${n.deviceVersionMajor}.${n.deviceVersionMinor}.${n.deviceVersionSubminor}`),o=n,t=f(o),t}catch(n){h("User didn't select any USB device when requesting permission:",n)}}navigator.usb.addEventListener("connect",i=>{t||(o=i.device,t=f(o))}),navigator.usb.addEventListener("disconnect",()=>{V()});async function V(){o=t=null;const i=await navigator.usb.getDevices();i.length>0&&(o=i[0],t=f(o))}return V(),{requestPermission:E,getDevices:m,openDevice:b,closeDevice:w,resetDevice:v,claimInterface:P,releaseInterface:B,getConfiguration:A,controlTransfer:L}}(),T=function(){let t=!1,o,s,d;const l=[],h=P("receive"),g=P("recieve errors");let f={connectionId:1,paused:!1,persistent:!1,name,bufferSize:4096,receiveTimeout:0,sendTimeout:0,bitrate:9600,dataBits:"eight",parityBit:"no",stopBits:"one",ctsFlowControl:!1};const m="SERIAL (adapted from WebSerial):";function b(r,...e){console.log(m+r,...e)}function w(r,...e){console.warn(m+r,...e)}function v(r,...e){console.error(m+r,...e)}function P(r){const e=[];return{addListener:function(a){e.push(a)},removeListener:function(a){const c=e.indexOf(a);c>=0?e.splice(c,1):v(`Asked to remove an unknown listener for ${r}`,a)},raiseEvent:function(a){if(a.byteLength!==0)for(const c of e)c({data:a})}}}async function*B(r,e){try{for(;e();)try{const{done:a,value:c}=await r.read();if(a)return;yield c}catch(a){w("Read error in streamAsyncIterable:",a);break}}finally{try{r?.locked&&r.releaseLock()}catch(a){w("Error releasing reader lock:",a)}}}const A=[{usbVendorId:1027,usbProductId:24577},{usbVendorId:1155,usbProductId:12886},{usbVendorId:1155,usbProductId:14158},{usbVendorId:1155,usbProductId:22336},{usbVendorId:4292,usbProductId:6e4},{usbVendorId:4292,usbProductId:60001},{usbVendorId:4292,usbProductId:60002},{usbVendorId:10473,usbProductId:394},{usbVendorId:11836,usbProductId:22336},{usbVendorId:12619,usbProductId:22336},{usbVendorId:11914,usbProductId:9}],L={1027:"FTDI",1155:"STM Electronics",4292:"Silicon Labs",11836:"AT32",12619:"Geehy Semiconductor",11914:"Raspberry Pi Pico"};function E(r){const e=r.getInfo(),a=L[e.usbVendorId]||`VID:${e.usbVendorId} PID:${e.usbProductId}`;return b("creating port desc",e),{path:`${e.usbVendorId}/${e.usbProductId}`,displayName:`Rotorflight ${a}`,vendorId:e.usbVendorId,productId:e.usbProductId,port:r}}function V(){const r=f.dataBits==="seven"?7:8,e=f.stopBits==="two"?2:1,a=f.parityBit==="no"?"none":f.parityBit;return{baudRate:f.bitrate,dataBits:r,stopBits:e,parity:a,bufferSize:f.bufferSize}}function i(r,e){return r===4292&&e===6e4?"Cp21xxSerialDriver":"CdcAcmSerialDriver"}async function n(r=!1){let e=null;try{const a=r?{}:{filters:A},c=await navigator.serial.requestPort(a);e=l.find(I=>I.port===c),e||(e=E(c),l.push(e)),b("User selected SERIAL device from permissions:",e.path)}catch(a){v("User didn't select any SERIAL device when requesting permission:",a)}return e}function u(r){try{r?.(l)}catch(e){w(`getDevices callback error ${e}`)}}async function y(){try{for await(let r of B(s,()=>t))h.raiseEvent(r)}catch(r){v("receive listener errored in read loop, disconnecting:",r),D(),g.raiseEvent({error:"device_lost"})}}async function p(r,e,a){f={...f,...e};const{port:c}=l.find(I=>I.path===r);if(c)try{const I=V();b("opening port with options",c,I),await c.open(I),o=c,s=c.readable.getReader(),d=c.writable.getWriter(),t=!0,y(),a?.({...f})}catch(I){v(I.message,I)}else v("could not find port by path",r),a()}async function S(r,e,a){try{await d.write(e),a?.({bytesSent:e.byteLength})}catch(c){v("error writing",c),a?.({bytesSent:0,error:c})}}async function D(r,e){if(!o){e?.(!0);return}const a=o;if(t=!1,s)try{await s.cancel()}catch(c){w("Reader cancel error (can be ignored):",c)}if(s=null,d){try{d.releaseLock()}catch(c){w("Writer release error (can be ignored):",c)}d=null}try{o=null,await a.close()}catch(c){v("error during close",c)}e?.(!0)}return navigator.serial.addEventListener("connect",r=>{b(`webserial port connected: ${r.target}`),l.push(E(r.target))}),navigator.serial.addEventListener("disconnect",r=>{b(`webserial port disconnected: ${r.target}`),l.splice(l.indexOf(r.target),1),g.raiseEvent({error:"device_lost"}),t=!1,s=null,d=null,o=null}),async function(){const e=await navigator.serial.getPorts();l.push(...e.map(a=>E(a)))}(),{getDriver:i,requestPermission:n,getDevices:u,connect:p,send:S,disconnect:D,onReceive:h,onReceiveError:g,setPaused:function(r,e,a){f.paused=e,a?.()},getInfo:function(r){r?.({...f})}}}(),N={lastError:void 0},$={local:{set:async function(t,o){if(arguments.length<1||arguments.length>2||!t||t.constructor!==Object||o&&typeof o!="function")throw new TypeError("Error in invocation of storage.set(object items, optional function callback): No matching signature.");Object.keys(t).forEach(s=>{localStorage.setItem(s,t[s]?JSON.stringify(t[s]):t[s])}),o?.()},remove:async function(t,o){let s=t;if(arguments.length>2||s&&typeof s!="string"&&!Array.isArray(s)||o&&typeof o!="function")throw new TypeError("Error in invocation of storage.remove([string|array] keys, optional function callback): No matching signature.");if(Array.isArray(s)&&s.find(d=>typeof d!="string"))throw new TypeError(" Error in invocation of storage.remove([string|array] keys, optional function callback): Error at parameter 'keys': Value did not match any choice.");typeof t=="string"?localStorage.removeItem(t):t.forEach(d=>{localStorage.removeItem(d)}),o?.()},get:async function(t,o){if(t&&t.constructor===Array&&t.find(l=>typeof l!="string"))throw new TypeError("Error in invocation of storage.get(optional [string|array|object] keys, function callback): Error at parameter 'keys': Value did not match any choice");if(arguments.length>2||typeof t=="number"||t&&!(typeof t!="string"||t.constructor!==Object||t.constructor!==Array)||o!==void 0&&typeof o!="function")throw new TypeError("Error in invocation of storage.get(optional [string|array|object] keys, function callback): No matching signature.");let s={},d;return t||(d=Object.keys(localStorage)),t?.constructor===Object&&(d=Object.keys(t)),t?.constructor===Array&&(d=t),typeof t=="string"&&(d=[t]),d?.forEach(l=>{const h=localStorage.getItem(l);h&&(s[l]=JSON.parse(h))}),o?.(s),{...s}}}};export{N as runtime,T as serial,$ as storage,C as usb};
